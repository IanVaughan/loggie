module Loggie
  # class Hash
  #   def compact(opts={})
  #     inject({}) do |new_hash, (k,v)|
  #       if !v.nil?
  #         new_hash[k] = opts[:recurse] && v.class == Hash ? v.compact(opts) : v
  #       end
  #       new_hash
  #     end
  #   end
  # end

  class Extract
    def self.call(result, keep = ["host", "agent"])
      return if result.nil?

      result.map do |r|
        {
          timestamp: Time.at(r["timestamp"] / 1000).to_datetime,
          message: format(r["message"])
        }
      end
    end

    def self.format(m)
      m = remove_rails_timestamp(m)
      m = safe_parse(m)
      m = remove_empty_fields(m)
    end

    def self.remove_rails_timestamp(message)
      message.sub(/.*-- : /, '')
    end

    def self.safe_parse(message)
      begin
        JSON.parse message
      rescue JSON::ParserError
        {}
      end
    end

    def self.remove_empty_fields(m)
      # proc1 = Proc.new { |k, v| v.kind_of?(Hash) ? (v.delete_if(&l); nil) : v.empty? }; hsh.delete_if(&proc)
      # proc2 = Proc.new { |k, v| v.kind_of?(Hash) ? (v.delete_if(&proc); nil) : v.empty? }; hsh.delete_if(&proc)
      binding.pry
      m.compact.reject { |m| m.empty? }
      # .except(*keep)
    end
  end
end
